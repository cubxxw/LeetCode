+ [author](https://github.com/3293172751)
<a href="https://github.com/3293172751" target="_blank"><img src="https://img.shields.io/badge/Github-xiongxinwei-inactive?style=social&logo=github"></a></p>

# ç¬¬18èŠ‚ äºŒå‰æ ‘é¢˜ç›®è¡¥å……

+ [å›åˆ°ç›®å½•](../README.md)
+ [å›åˆ°é¡¹ç›®é¦–é¡µ](../../README.md)
+ [ä¸Šä¸€èŠ‚](17.md)
> â¤ï¸ğŸ’•ğŸ’•ç®—æ³•å­¦ä¹ ç¬”è®°å’ŒLeetCodeçš„åˆ·é¢˜ç¬”è®°ä¸è®°å½•ã€‚Myblog:[http://nsddd.top](http://nsddd.top/)
---
[TOC]

## åˆ¤æ–­ä¸€é¢—äºŒå‰æ ‘æ˜¯å¦æ˜¯æœç´¢äºŒå‰æ ‘

+ [x] [leetcode](https://leetcode.cn/problems/validate-binary-search-tree)
+ [x] [leetcode.com](https://leetcode.com/problems/validate-binary-search-tree)

> äºŒå‰æ ‘çš„å¥—è·¯éƒ½æ˜¯å›ºå®šçš„

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚

æœ‰æ•ˆ äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š

1. èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
2. èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
3. æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚

ç¤ºä¾‹ 1ï¼š

![img](assets/tree1.jpg)

```
è¾“å…¥ï¼šroot = [2,1,3]
è¾“å‡ºï¼štrue
```

ç¤ºä¾‹ 2ï¼š

![img](assets/tree2.jpg)

```
è¾“å…¥ï¼šroot = [5,1,4,null,null,3,6]
è¾“å‡ºï¼šfalse
```

è§£é‡Šï¼šæ ¹èŠ‚ç‚¹çš„å€¼æ˜¯ 5 ï¼Œä½†æ˜¯å³å­èŠ‚ç‚¹çš„å€¼æ˜¯ 4 ã€‚

> æˆ‘ä»¬ä½¿ç”¨`ä¸­åºéå†`ï¼Œå¦‚æœéå†çš„ç»“æœæ˜¯`å‡åº`æ’åºçš„ï¼Œé‚£ä¹ˆè¿™ä¸ªäºŒå‰æ ‘ä¸€å®šæ˜¯ä¸ªäºŒå‰æœç´¢æ ‘ã€‚





### ä¸­åºéå†è§£é¢˜

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    long preVaLue = Long.MIN_VALUE;   //å¼€å§‹è®¾ç½®ä¸ºæ•´æ•°æœ€å°å€¼ int
    public boolean isValidBST(TreeNode root) {
        if(root == null) {
            return true;
        }
        boolean isleftBst = isValidBST(root.left);
        if(isleftBst == false) {
            //å¦‚æœå·¦æ•°ä¸æ˜¯æœç´¢äºŒå‰æ ‘ï¼Œé‚£å°±ç›´æ¥è¿”å›
            return false;
        }
        if(root.val <= preVaLue) {
            //å¦‚æœå‘ç°ä¸­åºéå†åé¢çš„æ•°å°äºpreVaLue
            return false;
        }else{   //>
            preVaLue = root.val;
        }
        boolean isrightBst = isValidBST(root.right);
        if(isrightBst == false) {
            return false;
        }else{
            return true;
         }
        //return  isValidBST(root.right);
    }
}
```

**Goè¯­è¨€**

```go
func isValidBST(root *TreeNode) bool {
    return helper(root, math.MinInt64, math.MaxInt64)
}

func helper(root *TreeNode, lower, upper int) bool {
    if root == nil {
        return true
    }
    if root.Val <= lower || root.Val >= upper {
        return false
    }
    return helper(root.Left, lower, root.Val) && helper(root.Right, root.Val, upper)
}
```



### ä½¿ç”¨å“ˆå¸Œè¡¨è®°å½•

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> list = new ArrayList<>(); 
    public boolean isValidBST(TreeNode root) {
        inOrderUnderRecur(root);
        for(int i=0;i<list.size()-1;i++){
            if(list.get(i)>=list.get(i+1)) return  false;
        }
        return true;
    }
    public  void inOrderUnderRecur(TreeNode root){
        /**
         * ç”³è¯·ä¸€ä¸ªæ ˆç©ºé—´stack
         * å…ˆå°†å½“å‰æ ¹èŠ‚ç‚¹å‹å…¥æ ˆç©ºé—´ ç„¶åä¸æ–­ éå†å·¦å­èŠ‚ç‚¹ å½“å·¦å­èŠ‚ç‚¹ä¸ºç©ºçš„æ—¶å€™
         * å¼¹å‡ºå½“å‰èŠ‚ç‚¹ å¹¶ä¸”æ‰“å° è¯¥èŠ‚ç‚¹çš„å€¼ï¼Œå¹¶ä¸”ä»è¯¥èŠ‚ç‚¹çš„å³å­©å­å¼€å§‹éå†å·¦å­èŠ‚ç‚¹
         * ä¸æ–­é‡å¤å‰é¢ä¸¤ä¸ªæ­¥éª¤ å½“æ ˆä¸ºç©ºçš„æ—¶å€™ä¸”å½“å‰èŠ‚ç‚¹ä¸ºç©ºçš„æ—¶å€™ ç»“æŸéå†
         */
         if(root==null) return;
         Stack<TreeNode> stack = new Stack<>();
         while (!stack.isEmpty()||root!=null){
             if(root!=null) {
                 stack.push(root);
                 root=root.left;
             }else {
                 root=stack.pop();
                 System.out.print(root.val+" ");
                 list.add(root.val);
                 root=root.right;
             }
         }
    }
}
```



### éé€’å½’æ–¹å¼å®ç°

å¯¹äºä¸­åºéå†è€Œè¨€ï¼Œ**è®¿é—®èŠ‚ç‚¹çš„é¡ºåºå’Œå¤„ç†èŠ‚ç‚¹çš„é¡ºåºæ˜¯ä¸ä¸€è‡´çš„**ï¼Œå¹¶ä¸”ï¼Œ**å¤„ç†èŠ‚ç‚¹æ˜¯åœ¨éå†å®Œå·¦å­æ ‘ä¹‹å**ã€‚



ç›´ç™½ç‚¹å°±æ˜¯ï¼š**ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¸€å±‚å±‚çš„éå†ï¼Œæ‰¾åˆ°å·¦å­æ ‘æœ€å·¦çš„é‚£ä¸ªèŠ‚ç‚¹ï¼Œä»å®ƒå¼€å§‹å¤„ç†èŠ‚ç‚¹ã€‚**



ä¾‹å¦‚ä¸‹å›¾ä¸­çš„ H èŠ‚ç‚¹ã€‚

![640.png](assets/a96abbf5298948d9857dd5a91c40a369.png)



å¸¸è§„çš„**ä¸­åºéå†å…·ä½“æ­¥éª¤**å¦‚ä¸‹æ‰€ç¤ºï¼š



- åˆå§‹åŒ–ä¸€ä¸ªç©ºæ ˆã€‚
- å½“ã€æ ¹èŠ‚ç‚¹ä¸ä¸ºç©ºã€‘æˆ–è€…ã€æ ˆä¸ä¸ºç©ºã€‘æ—¶ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹

- - è‹¥å½“å‰èŠ‚ç‚¹æœ‰å·¦å­æ ‘ï¼Œä¸€ç›´éå†å·¦å­æ ‘ï¼Œæ¯æ¬¡å°†å½“å‰èŠ‚ç‚¹å‹å…¥æ ˆä¸­ã€‚
  - è‹¥å½“å‰èŠ‚ç‚¹æ— å·¦å­æ ‘ï¼Œä»æ ˆä¸­å¼¹å‡ºè¯¥èŠ‚ç‚¹ï¼Œå°è¯•è®¿é—®è¯¥èŠ‚ç‚¹çš„å³å­æ ‘ã€‚



åœ¨æˆ‘ä»¬è¿™é“é¢˜ä¸­ï¼Œæˆ‘ä»¬è¿˜éœ€è¦åˆ¤æ–­ã€åºåˆ—æ˜¯å¦æœ‰åºã€‘ï¼Œè¿™å°±éœ€è¦æˆ‘ä»¬åœ¨ä»æ ˆä¸­å¼¹å‡ºèŠ‚ç‚¹çš„æ—¶å€™ï¼Œå’Œä¸Šä¸€æ¬¡å¼¹å‡ºçš„èŠ‚ç‚¹å€¼ä½œæ¯”è¾ƒï¼Œå¦‚æœå½“å‰çš„å€¼å¤§ï¼Œé‚£å°±ç»§ç»­ä¹‹å‰çš„æ“ä½œï¼Œå¦åˆ™å°±è¯æ˜ä¸æ˜¯äºŒå‰æœç´¢æ ‘ã€‚



ä»¥ä¸‹å›¾ä¸ºä¾‹ï¼š

![640.png](assets/52f6da9babb345428b602671bd6c3663.png)

é¦–å…ˆåˆå§‹åŒ–ä¸€ä¸ªç©ºæ ˆ stack å’Œä¸€ä¸ªä¿å­˜å‰ä¸€ä¸ªèŠ‚ç‚¹çš„ pre

![640.png](assets/2ebc7b80df7d429d92ff18a44a46f84b.png)



```
stack = []
# è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
pre = None
```

ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¸€ç›´å‘å·¦å­æ ‘éå†ï¼ŒåŒæ—¶å°†å½“å‰çš„èŠ‚ç‚¹å‹å…¥æ ˆä¸­ã€‚



![640.png](assets/c4b80fbcfe3b49f7a6badc9484b98780.png)



```
# ä¸€ç›´å‘å·¦å­æ ‘èµ°ï¼Œæ¯ä¸€æ¬¡å°†å½“å‰èŠ‚ç‚¹ä¿å­˜åˆ°æ ˆä¸­
if root:
    stack.append(root)
    root = root.left
```

å½“å‰èµ°åˆ°äº†æœ€å·¦é¢ï¼Œå¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œæ­¤æ—¶ cur = 1ï¼Œpre ä¸ºç©ºï¼Œè®© pre = curã€‚



![640.png](assets/cdc71890f66247afa291c1067d078b6a.png)



```
cur = stack.pop()
# åˆ¤æ–­åºåˆ—æ˜¯å¦æœ‰åº
if pre and cur.val <= pre.val:
    return False
pre = cur
root = cur.right
```



å¼¹å‡ºçš„èŠ‚ç‚¹ 1 å¹¶æ— å³å­æ ‘ï¼Œç»§ç»­é‡å¤ä¸Šè¿°çš„åŠ¨ä½œã€‚



å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œæ­¤æ—¶ cur = 2ï¼Œpre = 1ï¼Œcur > preï¼Œè¯æ˜å½“å‰æœ‰åºã€‚

![640.png](assets/01388f936cbf4d3783e18ca99b9db263.png)



æ­¤æ—¶è®© pre = curï¼ŒåŒæ—¶å½“å‰çš„èŠ‚ç‚¹ 2 æœ‰å³å­æ ‘ï¼Œéå†å…¶å³å­æ ‘ï¼Œéå†åˆ°çš„èŠ‚ç‚¹å…¥æ ˆã€‚

![640.png](assets/ce612785d4da4a92ac9a3ac621eeeb6c.png)



å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œæ­¤æ—¶ cur = 3ï¼Œpre = 2ï¼Œcur > preï¼Œè¯æ˜å½“å‰æœ‰åºã€‚

![640.png](assets/336fe04e47504f0490c5a85bba88a1cf.png)

æ­¤æ—¶è®© pre = curï¼ŒåŒæ—¶å¼¹å‡ºçš„èŠ‚ç‚¹ 3 å¹¶æ— å³å­æ ‘ï¼Œè‡³æ­¤äºŒå‰æ ‘å…¨éƒ¨éå†å®Œï¼Œè¿”å› Trueã€‚



Python ä»£ç å®ç°

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack = []
        # è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
        pre = None

        while root or stack:
            # ä¸€ç›´å‘å·¦å­æ ‘èµ°ï¼Œæ¯ä¸€æ¬¡å°†å½“å‰èŠ‚ç‚¹ä¿å­˜åˆ°æ ˆä¸­
            if root:
                stack.append(root)
                root = root.left
            # å½“å‰èŠ‚ç‚¹ä¸ºç©ºï¼Œè¯æ˜èµ°åˆ°äº†æœ€å·¦è¾¹ï¼Œä»æ ˆä¸­å¼¹å‡ºèŠ‚ç‚¹
            # å¼€å§‹å¯¹å³å­æ ‘é‡å¤ä¸Šè¿°è¿‡ç¨‹
            else:
                cur = stack.pop()
                # åˆ¤æ–­åºåˆ—æ˜¯å¦æœ‰åº
                if pre and cur.val <= pre.val:
                    return False
                pre = cur
                root = cur.right

        return True
```



Java ä»£ç å®ç°

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
        TreeNode pre = null;
        
        while(stack.size() > 0 || root != null){
            // ä¸€ç›´å‘å·¦å­æ ‘èµ°ï¼Œæ¯ä¸€æ¬¡å°†å½“å‰èŠ‚ç‚¹ä¿å­˜åˆ°æ ˆä¸­
            if(root != null){
                stack.add(root);
                root = root.left;
            }
            // å½“å‰èŠ‚ç‚¹ä¸ºç©ºï¼Œè¯æ˜èµ°åˆ°äº†æœ€å·¦è¾¹ï¼Œä»æ ˆä¸­å¼¹å‡ºèŠ‚ç‚¹
            // å¼€å§‹å¯¹å³å­æ ‘é‡å¤ä¸Šè¿°è¿‡ç¨‹
            else{
                TreeNode cur = stack.pop();
                // åˆ¤æ–­åºåˆ—æ˜¯å¦æœ‰åº
                if(pre != null && cur.val <= pre.val){
                    return false;
                }
                pre = cur;
                root = cur.right;
            }
        }
        return true;
    }
}
```



åŒæ ·ï¼Œéé€’å½’ç‰ˆçš„è§£æ³•**æ—¶é—´å¤æ‚åº¦ä¸º** **O(n)ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(n)**ã€‚

**å›¾è§£éªŒè¯äºŒå‰æœç´¢æ ‘**åˆ°è¿™å°±ç»“æŸäº†ï¼Œä½ çœ‹ï¼Œè™½ç„¶æ˜¯ä¸ªéš¾åº¦ä¸­ç­‰çš„é¢˜ï¼Œä¹Ÿåªæ˜¯ä¸ªçº¸è€è™ã€‚

æŒæ¡äº†äºŒå‰æœç´¢æ ‘çš„æ€§è´¨å°±æŒæ¡äº†è¿™é“é¢˜çš„è§£é¢˜å¯†ç ï¼Œå…¶å®è¿™é“é¢˜ä¹Ÿç»™æˆ‘ä»¬æä¾›äº†æ€è·¯ï¼Œæœ‰æ—¶å€™å¯ä»¥å¾€æœ¬èº«çš„æ€§è´¨ä¸Šé ä¸€ä¸‹ã€‚



### å¥—è·¯è§£é¢˜

**éœ€è¦æ»¡è¶³æ¡ä»¶**

+ å·¦è¾¹æœç´¢äºŒå‰æ ‘
+ å³è¾¹æœç´¢äºŒå‰æ ‘
+ å·¦è¾¹`max < x`
+ å³è¾¹`min > x`

> ä½ éœ€è¦å…ˆå·¦è¾¹è¦ä¸¤ä¸ªæ¡ä»¶ï¼Œå…ˆå³è¾¹è¦ä¸¤ä¸ªæ¡ä»¶ï¼Œæ‰€ä»¥æˆ‘ä»¬é€‰æ‹©å…¨éƒ¨éƒ½è¿”å›ä¸‰ä¸ªè¿”å›å€¼

```java
class Solution {
    public static ReturnDate process(TreeNode x) {
        if(x == null) {
            return null;   //å¯¹äºmaxå’Œminä¸å¥½åšå¤„ç†ï¼Œè¿”å›nullï¼Œåé¢åˆ¤æ–­
        }
        ReturnDate leftData = process(x.left);
        ReturnDate rightData = process(x.right);

        //æˆ‘ä¹Ÿéœ€è¦è¿”å›ä¸‰ä¸ªä¿¡æ¯
        int min = x.value;
        int max = x.value;
        if(leftData != null) {
            //å·¦æ ‘ä¸ä¸ºç©ºï¼Œpk
            min = Math.min(min,leftData.min);
            max = Math.max(max,leftData.max);
        }
        if(rithtData != null) {
            //å³æ ‘ä¸ä¸ºç©ºï¼Œpk
            min = Math.min(min,rightData.min);
            max = Math.max(max,rightData.max);
        }
        
        boolean isBST = true;   //è®¾ç½®æ˜¯å¦æœ‰
        if(leftData != null && (!leftData.isBST || leftData.max >= x.value)) {
            isBST = false;
            //å·¦è¾¹ä¸ä¸ºç©ºä¸”(å·¦è¾¹æœ‰ä¸œè¥¿ï¼Œä¸”å·¦è¾¹æœ€å¤§å€¼ > = x.value)
        }
        if(rightData != null && (!rightData.isBST || rithtData.min <= x.value)) {
            isBST = false;
        }

        return new ReturnDate(isBST,min,max);
    }
}
```



## åˆ¤æ–­å®Œå…¨äºŒå‰æ ‘

> åœ¨`å †`ä¸­æˆ‘ä»¬çŸ¥é“å•¦æ»¡äºŒå‰æ ‘ï¼Œåˆ¤æ–­æ–¹æ³•æ˜¯äºŒå‰æ ‘æŒ‰ç…§å®½åº¦éå†
>
> + ä¾æ¬¡éå†æ¯ä¸€ä¸ªç»“ç‚¹ï¼Œå¦‚æœæœ‰å³å­©å­ï¼Œæ²¡å·¦å­©å­ï¼Œä¸æ˜¯
> + ä¸Šä¸€æ¡ä»¶åŸºç¡€ä¸Šï¼Œå¦‚æœé‡åˆ°å·¦å³ä¸¤ä¸ªå­©å­ä¸åŒå…¨ï¼Œé‚£ä¹ˆä¹‹åé‡åˆ°çš„æ‰€æœ‰ç»“ç‚¹ï¼Œéƒ½å¿…é¡»æ˜¯å¶å­ç»“ç‚¹
>
> ![image-20220802163314518](assets/image-20220802163314518.png "å®Œå…¨äºŒå‰æ ‘åˆ¤æ–­")



### ä»£ç 

```java
public static boolean isCBT(Node head) {
    if(head == null) {
        return false;
    }
    
    LinkedList<Node> queue = nwe LinkedList<>();  //åˆ›å»ºé˜Ÿåˆ—
    //æ—¶å€™é‡åˆ°å·¦å³å­©å­ä¸åŒå…¨ç»“ç‚¹
    boolean leaf = false;   //è®¾ç½®æ ‡è®°ä½
    Node l = null;	//å·¦å­©å­ä¸ºç©º
    Node r = null;	//æœ‰å­©å­ä¸ºç©º
    queue.add(head);
    while(!queue.isEmpty()) {
        head = queue.poll();
        l = head.left;
        r = head.right;
        if ((leaf && (l != null || r != null)) || (l == null && r !== null)) {
            return false;
        }
    }
    if(l != null) {
        queue.add(l)ï¼›
    }
    if(r != null) {
        queue.add(r)ï¼›
    }
    if(l == null || r == null) {
        leaf = trueï¼›
    }
    return true;
}
```





## åˆ¤æ–­æ»¡äºŒå‰æ ‘

æ»¡äºŒå‰æ ‘çš„å®šä¹‰ï¼šä¸€ä¸ªé«˜åº¦ä¸ºhï¼Œå¹¶ä¸”å«æœ‰**2^h^ - 1**ä¸ªèŠ‚ç‚¹çš„äºŒå‰æ ‘ç§°ä¸ºæ»¡äºŒå‰æ ‘ï¼Œç§°å‘¼æ»¡äºŒå‰æ ‘ä¸º**FBT**ã€‚

æ ¹æ®æ»¡äºŒå‰æ ‘çš„é«˜åº¦ä¸èŠ‚ç‚¹ä¸ªæ•°ä¹‹é—´çš„å…³ç³»ï¼Œå¾ˆå®¹æ˜“åˆ¤æ–­ä¸€æ£µæ ‘æ˜¯å¦ä¸ºFBTï¼Œåªéœ€è¦æ±‚æ ‘å…¶æ ‘é«˜å’ŒèŠ‚ç‚¹ä¸ªæ•°å³å¯ã€‚

> æ‰€ä»¥æˆ‘ä»¬åˆ¤æ–­æ»¡äºŒå‰æ ‘å°±éœ€è¦ç”¨è¿™ä¸ªå…¬å¼äº†ï¼Œä½†æ˜¯éœ€è¦ä¸€ä¸ªå¥—è·¯æ¥è§£é¢˜

### å¥—è·¯è§£é¢˜

> å­¦ä¼šæ ‘å‹DPåï¼Œè¿™ç§ç±»å‹å°±å¾ˆå®¹æ˜“å†™äº†

### ä»£ç 

```java
class A{
 	public static class ReturnType {
        //ä¸¤ä¸ªè¿”å›å€¼
        public int nodes; 		//ä¸ªæ•°
        public int height;		//é«˜åº¦
        
        public ReturnType(int nod,int hei) {
            nodes = nod;
            height = hei;
        }
    }
    public static boolean isF(Node head) {
        if(head == null) {
            return true;
        }
        ReturnType data = process(head);   //æ”¶å–æ ‘çš„ä¿¡æ¯
        return data.nodes == (1 << (data.height - 1));
        //æ˜¯å¦ç­‰äº2 çš„ l æ¬¡æ–¹ - 1
    }
    public static ReturnType process(Node x) {
        if(x == null) {
            return new ReturnType(0, 0);    //é«˜åº¦å’Œç»“ç‚¹ä¸ªæ•°éƒ½æ˜¯0
        }

        ReturnType leftData = process(x.left);   //å·¦è¾¹å­æ ‘è¿”å›çš„ä¿¡æ¯
        ReturnType rightData = process(x.right); //å³è¾¹å­æ ‘è¿”å›çš„ä¿¡æ¯

        //int height;
        //int nodes;
        int height = Math.max(leftData.height,rightData.height) + 1;
        int nodes = leftData.nodes + rightData.nodes + 1;
        return new process(height,nodes);
    }
}
```





## åˆ¤æ–­å¹³è¡¡äºŒå‰æ ‘

+ [x] [leetcode](https://leetcode.cn/problems/balanced-binary-tree/)
+ [x] [leetcode.com](https://leetcode.com/problems/balanced-binary-tree/)

**å¯¹äºä»»ä½•ä¸€ä¸ªå­æ ‘æ¥è¯´ï¼Œå®ƒçš„å·¦æ•°å’Œå³æ•°çš„é«˜åº¦ç»å¯¹å€¼å·®`<=1`**

<img src="assets/1620.png" alt="å¹³è¡¡äºŒå‰æ ‘" style="zoom:80%;" />

### ä»£ç (å¥—è·¯è§£é¢˜)

**java**

```java
class A{
 	public static class ReturnType {
        //ä¸¤ä¸ªè¿”å›å€¼
        public boolean isBalanced;  //æ˜¯å¦å¹³è¡¡
        public int height;		   //é«˜åº¦
        
        public ReturnType(boolean isB,int hei) {
            isBalanced = isB;
            height = hei;
        }
    }
    public static ReturnType process(Node x) {
        if(x == null) {   //1
            return new ReturnType(true, 0);
        }
        
        //2  å·¦å³å­æ ‘çš„é€’å½’ä¿¡æ¯
        ReturnType leftData = process(x.left);     //å·¦æ ‘å¯ä»¥è¿”å›å¯¹åº”ä¸¤ä¸ªä¿¡æ¯
        ReturnType rightData = process(x.right);   //å³æ ‘å¯ä»¥è¿”å›å¯¹åº”ä¸¤ä¸ªä¿¡æ¯
    
    	//3. æˆ‘ä¹Ÿè¿”å›ä¸¤ä¸ªä¿¡æ¯   
        int height = Math.max(leftData.height,rightData.height) + 1;  //è¿”å›å¤§çš„é‚£ä¸ªé«˜åº¦+1 = æˆ‘çš„é«˜åº¦
        boolean isBalanced = leftData.isBalanced && rightData.isBalanced && Math.abs(leftData.height - rightData.height) < 2;
        //å·¦å¹³è¡¡æ ‘ + å³å¹³è¡¡æ ‘ + å·¦å³ç»å¯¹å€¼<1
    return  new ReturnType(isBalanced, height);
    }
}
```



**Goè¯­è¨€**

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isBalanced(root *TreeNode) bool {
    if root == nil {
        return true
    }
    return abs(height(root.Left) - height(root.Right)) <= 1 && isBalanced(root.Left) && isBalanced(root.Right)
    //å¯¹åº”çš„æ˜¯å·¦å­©å­å‡å»å³å­©å­ï¼Œè€Œä¸”å·¦å­©å­å­˜åœ¨ï¼Œå³å­©å­ä¹Ÿå­˜åœ¨
}

func height(root *TreeNode) int {
    if root == nil {
        return 0
    }

    return max(height(root.Left), height(root.Right)) + 1
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}

func abs(x int) int {
    if x < 0 {
        return -1 * x
    }
    return x
}

```



## äºŒå‰æ ‘é€’å½’å¥—è·¯

+ [x] [å¾ˆå¥½çš„ä¸€ä¸ªç½‘ç«™å¯ä»¥å­¦ä¹ ](https://oi-wiki.org/dp/)

**äºŒå‰æ ‘ä¸­æœ€éš¾çš„æ˜¯`æ ‘å‹DP`**

[^æ ‘å‹DP]: æ ‘å‹åŠ¨æ€è§„åˆ’é¢˜ç›®

**ç±»å‹é¢˜ç›®ï¼Œå¯ä»¥å¾ˆå¤šçš„é€šè§£ï¼Œä¸€èˆ¬éƒ½æ˜¯å‘å·¦æ ‘è¦ä¿¡æ¯ï¼Œå³æ ‘è¦ä¿¡æ¯ã€‚**

[toc]



## äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

+ [x] [leetcode236](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
+ [x] [leetcode.com](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€

**Example 1:**

![img](assets/binarytree.png)

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
```

**Example 2:**

![img](assets/binarytree.png)

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```
Input: root = [1,2], p = 1, q = 2
Output: 1
```

### ä»£ç 

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        def func(root,p,l):
            if not root: return False
            if root==p: 
                l.append(p)
                return True
            l.append(root)
            lFlag = func(root.left,p,l)
            if lFlag: return True
            rFlag = func(root.right,p,l)
            if rFlag: return True
            l.pop()
            return False
        
        path_p, path_q = [], []
        func(root, p, path_p) # æŸ¥æ‰¾pçš„è·¯å¾„
        func(root, q, path_q) # æŸ¥æ‰¾qçš„è·¯å¾„

        if not path_p: return p # å¦‚æœpè·¯å¾„ä¸ºç©ºï¼Œè¯´æ˜pæ˜¯èµ·ç‚¹ï¼Œç›´æ¥è¿”å›p
        if not path_q: return q # å¦‚æœqè·¯å¾„ä¸ºç©ºï¼Œè¯´æ˜qæ˜¯èµ·ç‚¹ï¼Œç›´æ¥è¿”å›q
        for item in path_p[::-1]: # æ‰¾åˆ°på’Œqçš„å…¬å…±èŠ‚ç‚¹
            if item in path_q:
                return item

        return -1

```



## END é“¾æ¥

+ [å›åˆ°ç›®å½•](../README.md)
+ [ä¸Šä¸€èŠ‚](17.md)
+ [ä¸‹ä¸€èŠ‚](19.md)
---
+ [å‚ä¸è´¡çŒ®â¤ï¸ğŸ’•ğŸ’•](https://github.com/3293172751/Block_Chain/blob/master/Git/git-contributor.md)