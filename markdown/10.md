+ [author](https://github.com/3293172751)
  <a href="https://github.com/3293172751" target="_blank"><img src="https://img.shields.io/badge/Github-xiongxinwei-inactive?style=social&logo=github"></a></p>

# ç¬¬10èŠ‚ å•é“¾è¡¨æ•°æ®ç»“æ„

+ [å›åˆ°ç›®å½•](../README.md)
+ [å›åˆ°é¡¹ç›®é¦–é¡µ](../../README.md)
+ [ä¸Šä¸€èŠ‚](9.md)

> â¤ï¸ğŸ’•ğŸ’•ç®—æ³•å­¦ä¹ ç¬”è®°å’ŒLeetCodeçš„åˆ·é¢˜ç¬”è®°ä¸è®°å½•ã€‚Myblog:[http://nsddd.top](http://nsddd.top/)

---

[TOC]



## å•é“¾è¡¨çš„ç»“ç‚¹ç»“æ„

```
Class Node(v) {
	V value;
	Node next;
}
```

**ç”±ä»¥ä¸Šç»“ç‚¹ä¾æ¬¡è¿æ¥èµ·æ¥çš„æ‰€å½¢æˆçš„é“¾å«åšå•é“¾è¡¨ç»“æ„**



## åŒé“¾è¡¨çš„ç»“ç‚¹ç»“æ„

```
Class Node(v) {
	V value;
	Node next;
	node last;
}
```

**ç”±ä»¥ä¸Šç»“ç‚¹ä¾æ¬¡è¿æ¥èµ·æ¥çš„æ‰€å½¢æˆçš„é“¾å«åšåŒé“¾è¡¨ç»“æ„**

> å•é“¾è¡¨å’ŒåŒé“¾è¡¨éƒ½åªéœ€è¦ç»™ä¸€ä¸ªå¤´éƒ¨ç»“ç‚¹headï¼Œå°±å¯ä»¥æ‰¾åˆ°å‰©ä¸‹çš„æ‰€æœ‰ç»“ç‚¹



## åŸºç¡€é¢˜

### å•å‘é“¾è¡¨å’ŒåŒå‘é“¾è¡¨çš„åè½¬

+  [leetcode206](https://leetcode.com/problems/reverse-linked-list/)

Given the `head` of a singly linked list, reverse the list, and return *the reversed list*.

**Example 1:**

![img](assets/rev1ex1.jpg)

```
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```

**Example 2:**

![img](assets/rev1ex2.jpg)

```
Input: head = [1,2]
Output: [2,1]
```

**Example 3:**

```
Input: head = []
Output: []
```

#### è§£é¢˜

> å…³äºè¿™é“é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘å°†æ•°æ®æ”¾åœ¨æ ˆé‡Œé¢ï¼Œç”¨åˆ°æ ˆçš„å…ˆè¿›åå‡ºçš„åŸåˆ™ä¾æ¬¡å¼¹å‡º

![image-20220723181248132](assets/image-20220723181248132.png)

##### Goè¯­è¨€

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode  //å®šä¹‰ä¸€ä¸ªé“¾è¡¨
    curr := head
    for curr != nil {
        next := curr.Next
        curr.Next = prev   //æ”¹å˜é“¾è¡¨
        prev = curr  //
        curr = next
    }
    return prev
}
```

##### python

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre, cur = None, head
        while cur:
            tmp = cur.next   #ä¿å­˜å½“å‰ç»“ç‚¹
            cur.next = pre
            pre = cur
            cur = tmp    #å½“å‰ç»“ç‚¹æ˜¯ä¹‹å‰ä¿å­˜çš„ç»“ç‚¹  åç§»ä¸€ä½
        return pre   #è¿”å›çš„æ˜¯å‰ä¸€ä¸ªç»“ç‚¹        
    
```

##### java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
    ListNode pre = null;
    ListNode cur = head;
    while(cur != null){
        ListNode tmp = cur.next;    //ä¿å­˜ä¸‹ä¸€ä¸ªç»“ç‚¹
        cur.next = pre;    //æŒ‡å‘å‰ä¸€ä¸ªç»“ç‚¹
        pre = cur;    //ä¿å­˜åç»­çš„ç»“ç‚¹
        cur = tmp;   //å½“å‰ç»“ç‚¹æ˜¯ä¹‹å‰ä¿å­˜çš„å“ªä¸ªç»“ç‚¹
        }
    return pre;
    }
}
```

##### C++

```Cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
    ListNode* pre = nullptr;
    ListNode* cur = head;
    while(cur != nullptr){
        ListNode* tmp = cur->next;    //ä¿å­˜ä¸‹ä¸€ä¸ªç»“ç‚¹
        cur->next = pre;    //æŒ‡å‘å‰ä¸€ä¸ªç»“ç‚¹
        pre = cur;    //ä¿å­˜åç»­çš„ç»“ç‚¹
        cur = tmp;   //å½“å‰ç»“ç‚¹æ˜¯ä¹‹å‰ä¿å­˜çš„å“ªä¸ªç»“ç‚¹
        }
    return pre;
    }        
};
```



##### cè¯­è¨€

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* reverseList(struct ListNode* head){
    struct ListNode* pre = NULL;
    struct ListNode* cur = head;
    while(cur != NULL)
    {
        struct ListNode* tmp = cur->next;    //ä¿å­˜ä¸‹ä¸€ä¸ªç»“ç‚¹
        cur->next = pre;    //æŒ‡å‘å‰ä¸€ä¸ªç»“ç‚¹
        pre = cur;    //ä¿å­˜åç»­çš„ç»“ç‚¹
        cur = tmp;   //å½“å‰ç»“ç‚¹æ˜¯ä¹‹å‰ä¿å­˜çš„å“ªä¸ªç»“ç‚¹
        }
    return pre;
}
```

##### JavaScript

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    var prev = null  //å®šä¹‰ä¸€ä¸ªé“¾è¡¨
    var curr = head
    while(curr) {
        const next = curr.next;
        curr.next = prev;   //æ”¹å˜é“¾è¡¨
        prev = curr;  
        curr = next;
    }
    return prev;
};
```



### æ‰“å°ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„å…¬å…±éƒ¨åˆ†

```

```



## è¿›é˜¶é¢˜

### é¢è¯•æ—¶é“¾è¡¨è§£é¢˜çš„æ–¹æ³•è®º

+ å¯¹äºç¬”è¯•ï¼Œä¸ç”¨å¤ªåœ¨ä¹ç©ºé—´å¤æ‚åº¦ï¼Œä¸€åˆ‡ä¸ºäº†æ—¶é—´å¤æ‚åº¦
+ å¯¹äºé¢è¯•ï¼Œæ—¶é—´å¤æ‚åº¦ä¾ç„¶æ”¾åœ¨ç¬¬ä¸€ä½ï¼Œä½†æ˜¯ä¸€å®šè¦æ‰¾åˆ°ç©ºé—´æœ€çœçš„æ–¹æ³•

**é‡è¦æŠ€å·§**

1. é¢å¤–æ•°æ®ç»“æ„è®°å½•ï¼ˆå“ˆå¸Œè¡¨ç­‰ï¼‰
2. å¿«æ…¢æŒ‡é’ˆ



### åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡ç»“æ„

+ [leetcode](https://leetcode.cn/problems/aMhZSa/)

ç»™å®šä¸€ä¸ªé“¾è¡¨çš„ å¤´èŠ‚ç‚¹ head ï¼Œè¯·åˆ¤æ–­å…¶æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚

å¦‚æœä¸€ä¸ªé“¾è¡¨æ˜¯å›æ–‡ï¼Œé‚£ä¹ˆé“¾è¡¨èŠ‚ç‚¹åºåˆ—ä»å‰å¾€åçœ‹å’Œä»åå¾€å‰çœ‹æ˜¯ç›¸åŒçš„ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](assets/1626421737-LjXceN-image.png)

```
è¾“å…¥: head = [1,2,3,3,2,1]
è¾“å‡º: true
```

**ç¤ºä¾‹ 2ï¼š**

![img](assets/1626422231-wgvnWh-image.png)

```
è¾“å…¥: head = [1,2]
è¾“å‡º: false
```



#### è§£é¢˜

**ç¬”è¯•æ–¹æ³•**

> 1. ç¬”è¯•ä¸­æˆ‘ä»¬å¯ä»¥è€ƒè™‘**æ”¾åœ¨æ ˆä¸­**ï¼Œå…ˆè¿›åå‡ºï¼ˆå¯ä»¥**åªæ”¾ä¸€åŠ**çš„æ•°æ®è¿›å»ï¼‰
> 2. è®¾ç½®**å¿«æ…¢æŒ‡é’ˆ**ï¼Œéƒ½ä»`0`ä¸‹æ ‡å¼€å§‹ï¼Œå¿«æŒ‡é’ˆä¸€æ¬¡ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆä¸€æ¬¡ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆèµ°å®Œçš„æ—¶å€™æ…¢æŒ‡é’ˆå¼€å§‹æ”¾å…¥é“¾è¡¨ï¼ˆåˆ¤æ–­å¥‡å¶æ€§ï¼‰ã€‚

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        Stack<ListNode> stack = new Stack<ListNode>();   //å‡†å¤‡ä¸€ä¸ªæ ˆ
            ListNode cur = head;
            while(cur != null) {
                //å¦‚æœç»“ç‚¹ä¸ä¸ºç©ºï¼Œå°±å…¨éƒ¨å‹å…¥æ ˆ
                stack.push(cur);
                cur = cur.next;
            }
            while(head != null) {
                //å¤´ç»“ç‚¹ä¸ä¸ºç©º
                if(head.val != stack.pop().val) {
                    return false;
                }
                head = head.next;
            }
            return true;
    }
}
```

**é¢è¯•æ–¹æ³•**

> 1. é¢è¯•ä¸­æˆ‘ä»¬ä½¿ç”¨æ”¹é“¾è¡¨çš„æ–¹å¼ï¼ˆå‰é¢ä¸€åŠçš„æ•°æ®ä¸å˜ï¼Œåé¢ä¸€åŠçš„æ•°æ®åè¿‡æ¥ â€“ åè½¬é“¾è¡¨ï¼‰ï¼Œæ”¹å®Œåæˆ‘ä»¬å†æŠŠé“¾è¡¨è°ƒå›æ¥.

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) {
            return true;
        }
        ListNode n1 = head;
        ListNode n2 = head;
        //è®¾ç½®å¿«æ…¢æŒ‡é’ˆå¼€å§‹éƒ½æŒ‡å‘çš„æ˜¯å¤´ç»“ç‚¹head
        while(n2.next != null && n2.next.next != null) {    
            //å¿«æ…¢æŒ‡é’ˆä¸‹ä¸€èŠ‚ç‚¹ä¸ä¸ºç©º,ç»§ç»­èµ°
            n1 = n1.next;
            n2 = n2.next.next;
        }
        //å¿«æŒ‡é’ˆèµ°åˆ°å¤´äº†å°±æ²¡æœ‰ä»·å€¼äº†ï¼Œå¯ä»¥è®°å½•æ…¢æŒ‡é’ˆçš„ä½ç½®
        n2 = n1.next;
        n1.next = null;
        ListNode n3 = null;
        while(n2 != null) {
            //n2ä¸æ–­åœ°å‘å‰èµ°
            n3 = n2.next;    //n3æŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹
            n2.next = n1;
            n1 = n2;   //n1 move 
            n2 = n3;   //n2 move
        }
        n3 = n1;
        n2 = head;
        boolean res = true;
        while(n1 != null && n2 != null) {
            if(n1.val != n2.val) {
                //å·¦å³ä¸ç›¸ç­‰è¯´æ˜äº†ä¸æ˜¯å›æ–‡
                res = false;
                break;
            }
            n1 = n1.next;
            n2 = n2.next;
        }
        //è¿”å›ä¹‹å‰ä¸è¦å¿˜è®°æŠŠå³éƒ¨åˆ†é€†åºå›æ¥
        n1 = n3.next;
        n3.next = null;
        while(n1 != null) {
            n2 = n1.next;
            n1.next = n3;
            n3 = n1;
            n1 = n2;
        }
        return res;
    }
}
```



### å•é“¾è¡¨åˆ’åˆ†å·¦å°å³å¤§ä¸­é—´ç›¸ç­‰å½¢å¼

- æ™®é€šæ–¹æ³•ï¼Œå°†é“¾è¡¨èŠ‚ç‚¹æ”¾åˆ°æ•°ç»„ç„¶åpartition
- è¿›é˜¶æ–¹æ³•ï¼Œå°†é“¾è¡¨åˆ’åˆ†æˆä¸‰ä¸ªå­é“¾è¡¨ï¼Œç„¶ååˆå¹¶

#### æ™®é€šæ–¹æ³•

æ™®é€šæ–¹æ³•ï¼Œå°†é“¾è¡¨èŠ‚ç‚¹æ”¾åˆ°æ•°ç»„ç„¶åpartition
è¿™ä¸ªæ–¹æ³•æ¯”è¾ƒç®€å•ï¼Œç›´æ¥å°†é“¾è¡¨ä¸­çš„å€¼ä¿å­˜åˆ°ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œç„¶åæŒ‰ç…§è·å…°å›½æ——çš„åˆ’åˆ†æ–¹å¼ï¼Œå°†æ•°ç»„åˆ’åˆ†æˆå·¦è¾¹å°äºé‚£ä¸ªæ•°ï¼Œä¸­é—´ç­‰äºé‚£ä¸ªæ•°ï¼Œå³è¾¹å¤§äºé‚£ä¸ªæ•°çš„å½¢å¼ï¼Œ(è·å…°å›½æ——é—®é¢˜ç”¨äºå¿«é€Ÿæ’åºä¸­çš„partitionè¿‡ç¨‹)ï¼›

åˆ’åˆ†å®Œä¹‹åï¼Œå†æŠŠæ•°ç»„ä¸­çš„å€¼ç”¨é“¾è¡¨çš„å½¢å¼è¿æ¥èµ·æ¥ã€‚ã€€ä½†æ˜¯è¿™ä¸ªæ–¹æ³•éœ€è¦é¢å¤–çš„O(n)çš„ç©ºé—´å¤æ‚åº¦ï¼Œè€Œä¸”partitionä¸èƒ½è¾¾åˆ°ç¨³å®šæ€§(å°±æ˜¯ä¼šæ”¹å˜åŸæ¥çš„ç›¸å¯¹é¡ºåº)ï¼›

```java
static class Node {
    public int value;
    public Node next;

    public Node(int value) {
        this.value = value;
    }
}

//æ™®é€šçš„éœ€è¦é¢å¤–ç©ºé—´O(n)ä¸”ä¸èƒ½è¾¾åˆ°ç¨³å®šæ€§çš„ã€€æ–¹æ³•
static Node partitionList_1(Node head, int pivot) { //pivotè¡¨ç¤ºã€€æ¢è½´ï¼›ä¸­å¿ƒç‚¹ï¼›æ—‹è½¬è¿åŠ¨
    if (head == null) return null;
    Node cur = head;
    int len = 0;
    while (cur != null) {
        len++;
        cur = cur.next;
    }
    Node[] nodeArr = new Node[len];
    cur = head;
    for (int i = 0; i < nodeArr.length; i++) {
        nodeArr[i] = cur;
        cur = cur.next;
    }
    arrPartition(nodeArr, pivot);
    for (int i = 1; i < nodeArr.length; i++) {
        nodeArr[i - 1].next = nodeArr[i];
    }
    nodeArr[nodeArr.length - 1].next = null;  //ä¸€å®šè¦è®°å¾—æŠŠæœ€åä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘null
    return nodeArr[0];
}

//æ•°ç»„åˆ’åˆ†çš„paration
static void arrPartition(Node[] nodeArr, int pivot) {
    int less = -1;
    int more = nodeArr.length;
    int cur = 0;
    while (cur < more) {
        if (nodeArr[cur].value < pivot) {
            swap(nodeArr, ++less, cur++);
        } else if (nodeArr[cur].value > pivot) {
            swap(nodeArr, --more, cur); //æ³¨æ„æ”¾åˆ°å¤§äºåŒºåŸŸçš„æ—¶å€™curä¸èƒ½++
        } else {
            cur++;
        }
    }
}

//äº¤æ¢ä¸¤ä¸ªç»“ç‚¹
static void swap(Node[] arrNode, int a, int b) {
    Node temp = arrNode[a];
    arrNode[a] = arrNode[b];
    arrNode[b] = temp;
}
```



#### è¿›é˜¶æ–¹æ³•

è¿›é˜¶æ–¹æ³•ï¼Œå°†é“¾è¡¨åˆ’åˆ†æˆä¸‰ä¸ªå­é“¾è¡¨ï¼Œç„¶ååˆå¹¶
**è¿™ä¸ªæ–¹æ³•æ˜¯å°†åŸæ¥çš„é“¾è¡¨ä¾æ¬¡åˆ’åˆ†æˆä¸‰ä¸ªé“¾è¡¨ï¼Œä¸‰ä¸ªé“¾è¡¨åˆ†åˆ«ä¸ºsmallä»£è¡¨çš„æ˜¯å·¦è¾¹å°äºçš„éƒ¨åˆ†ï¼Œequalä»£è¡¨çš„æ˜¯ä¸­é—´ç›¸ç­‰çš„éƒ¨åˆ†ï¼Œbigä»£è¡¨çš„æ˜¯å³è¾¹çš„å¤§äºéƒ¨åˆ†ï¼›**
è¿™ä¸‰ä¸ªé“¾è¡¨éƒ½æœ‰è‡ªå·±çš„ä¸¤ä¸ªæŒ‡é’ˆHeadå’ŒTailåˆ†åˆ«ä»£è¡¨å„è‡ªçš„å¤´éƒ¨å’Œå°¾éƒ¨ï¼Œåˆ†æˆä¸‰ä¸ªå­é“¾è¡¨ä¹‹åï¼Œæˆ‘ä»¬åªéœ€è¦éå†é“¾è¡¨ï¼Œç„¶åå’Œç»™å®šçš„å€¼æ¯”è¾ƒï¼ŒæŒ‰ç…§æ¡ä»¶ï¼Œå‘ä¸‰ä¸ªé“¾è¡¨ä¸­æ·»åŠ å€¼å°±å¯ä»¥äº†ï¼Œæœ€åæŠŠä¸‰ä¸ªé“¾è¡¨è¿æ¥èµ·æ¥å°±å¯ä»¥äº†ï¼›

![image-20220723145010419](assets/image-20220723145010419.png)

```java
//ç¬¬äºŒç§ã€€è¿›é˜¶çš„æ–¹æ³•ã€€ä¸éœ€è¦é¢å¤–çš„ç©ºé—´å¤æ‚åº¦ï¼Œä¸”èƒ½è¾¾åˆ°ç¨³å®šæ€§
static Node partitionList_2(Node head,int piovt){
    if(head == null)return null;
    Node sH = null,sT = null; //å°äºéƒ¨åˆ†é“¾è¡¨çš„  head å’Œtail
    Node eH = null,eT = null; //ç­‰äºéƒ¨åˆ†é“¾è¡¨çš„ã€€head å’Œtail
    Node bH = null,bT = null; //å¤§äºéƒ¨åˆ†é“¾è¡¨çš„ã€€head å’Œtail

    Node next = null;  //ç”¨æ¥ä¿å­˜ä¸‹ä¸€ä¸ªç»“ç‚¹

    //åˆ’åˆ†åˆ°ã€€ä¸‰ä¸ªä¸åŒçš„é“¾è¡¨
    while(head != null){
        next = head.next;
        head.next = null; //è¿™ä¸ªæ˜¯ä¸ºäº†é“¾è¡¨æ‹¼æ¥åã€€æœ€åä¸€ä¸ªå°±ä¸ç”¨å†å»èµ‹å€¼å…¶nextåŸŸä¸ºnull äº†
        if(head.value < piovt){  //å‘ã€€small éƒ¨åˆ†ã€€åˆ†å¸ƒ
            if(sH == null){ //å¦‚æœæ˜¯smalléƒ¨åˆ†çš„ç¬¬ä¸€ä¸ªç»“ç‚¹
                sH = head;  //å°äºåŒºå—çš„å¤´å’Œå°¾
                sT = head;
            }else {
                sT.next = head; //æŠŠheadæ”¾åˆ°smallæœ€åä¸€ä¸ª
                sT = head;  //æ›´æ–°smalléƒ¨åˆ†çš„sT
            }
        }else if(head.value == piovt){   //ç­‰äºåŒºåŸŸ
            if(eH == null){
                eH = head;
                eT = head;
            }else{
                eT.next = head;
                eT = head;
            }
        }else {          //å¤§äºåŒºåŸŸ
            if(bH == null){
                bH = head;
                bT = head;
            }else {
                bT.next = head;
                bT = head;
            }
        }
        head = next;
    }

    //å°†ä¸‰ä¸ªé“¾è¡¨åˆå¹¶(æ³¨æ„è¾¹ç•Œçš„åˆ¤æ–­)

    if(null != sT) { //åˆå¹¶smallå’Œequaléƒ¨åˆ†
        sT.next = eH;
        eT = eT == null ? sT : eT;
    }
    if(null != eT){
        eT.next = bH;
    }

    return sH != null ? sH : eH != null ? eH : bH;
}
```



### å¤æ‚é“¾è¡¨çš„å¤åˆ¶

+ [å‰‘æŒ‡ Offer 35. å¤æ‚é“¾è¡¨çš„å¤åˆ¶](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/) 

è¯·å®ç° `copyRandomList` å‡½æ•°ï¼Œå¤åˆ¶ä¸€ä¸ªå¤æ‚é“¾è¡¨ã€‚åœ¨å¤æ‚é“¾è¡¨ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹é™¤äº†æœ‰ä¸€ä¸ª `next` æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿˜æœ‰ä¸€ä¸ª `random` æŒ‡é’ˆæŒ‡å‘é“¾è¡¨ä¸­çš„ä»»æ„èŠ‚ç‚¹æˆ–è€… `null`ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](assets/e1.png)

```
è¾“å…¥ï¼šhead = [[7,null],[13,0],[11,4],[10,2],[1,0]]
è¾“å‡ºï¼š[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**ç¤ºä¾‹ 2ï¼š**

![img](assets/e2.png)

```
è¾“å…¥ï¼šhead = [[1,1],[2,1]]
è¾“å‡ºï¼š[[1,1],[2,1]]
```

**ç¤ºä¾‹ 3ï¼š**





**![img](assets/e3.png)**

```
è¾“å…¥ï¼šhead = [[3,null],[3,0],[3,null]]
è¾“å‡ºï¼š[[3,null],[3,0],[3,null]]
```

**ç¤ºä¾‹ 4ï¼š**

```
è¾“å…¥ï¼šhead = []
è¾“å‡ºï¼š[]
è§£é‡Šï¼šç»™å®šçš„é“¾è¡¨ä¸ºç©ºï¼ˆç©ºæŒ‡é’ˆï¼‰ï¼Œå› æ­¤è¿”å› nullã€‚
```

#### è§£é¢˜

+ å¦‚æœæ˜¯ç¬”è¯•çš„è¯ï¼Œä½¿ç”¨é¢å¤–çš„ç©ºé—´å¾ˆå¥½è§£å†³ï¼Œç”¨hashè¡¨çš„æ–¹æ³•

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {
        HashMap<Node,Node> map = new HashMap<Node,Node>();
        //ç”Ÿæˆå“ˆå¸Œè¡¨
        Node cur = head;
        while(cur != null) {
            map.put(cur, new Node(cur.val));
            cur = cur.next;
            //åšå‡ºå…‹éš†ç»“ç‚¹åˆ’åˆ†åˆ°mapï¼Œæ¯ä¸ªç»“ç‚¹éƒ½æ˜¯å¦‚æ­¤
        }
        cur = head;
        while(cur != null) {
            // cur è€
            // map.ger(cur) æ–°
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        return map.get(head);
    }
}
```



### ä¸¤ä¸ªé“¾è¡¨ç›¸äº¤çš„é—®é¢˜

+ [leetcodeé¢è¯•é¢˜52](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

#### é¢˜ç›®æè¿°

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)

```
è¾“å…¥ï¼šintersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
è¾“å‡ºï¼šReference of the node with value = 8
è¾“å…¥è§£é‡Šï¼šç›¸äº¤èŠ‚ç‚¹çš„å€¼ä¸º 8 ï¼ˆæ³¨æ„ï¼Œå¦‚æœä¸¤ä¸ªåˆ—è¡¨ç›¸äº¤åˆ™ä¸èƒ½ä¸º 0ï¼‰ã€‚ä»å„è‡ªçš„è¡¨å¤´å¼€å§‹ç®—èµ·ï¼Œé“¾è¡¨ A ä¸º [4,1,8,4,5]ï¼Œé“¾è¡¨ B ä¸º [5,0,1,8,4,5]ã€‚åœ¨ A ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 2 ä¸ªèŠ‚ç‚¹ï¼›åœ¨ B ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 3 ä¸ªèŠ‚ç‚¹ã€‚
```

- å•é“¾è¡¨å¯èƒ½æœ‰ç¯, ä¹Ÿå¯èƒ½æ— ç¯. ä¸¤ä¸ªé“¾è¡¨å¯èƒ½ç›¸äº¤, å¯èƒ½ä¸ç›¸äº¤. å®ç°ä¸€ä¸ªå‡½æ•°, å¦‚æœä¸¤ä¸ªé“¾è¡¨ç›¸äº¤, åˆ™è¿”å›ç›¸äº¤çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹; å¦‚æœä¸ç›¸äº¤, è¿”å›nullå³å¯.
- é“¾è¡¨çš„é•¿åº¦ä¸ºM, N. è¦æ±‚æ—¶é—´å¤æ‚åº¦è¾¾åˆ°O(M+N), é¢å¤–ç©ºé—´å¤æ‚åº¦è¾¾åˆ°O(1).

#### è§£é¢˜æ€è·¯

- æ­¤é¢˜ç›®å¯ä»¥æ‹†åˆ†æˆä¸‰ä¸ªå­é—®é¢˜:
  - å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦æœ‰ç¯, å¦‚æœæœ‰, åˆ™è¿”å›ç¬¬ä¸€ä¸ªè¿›å…¥ç¯çš„èŠ‚ç‚¹, æ²¡æœ‰åˆ™è¿”å›null.
  - å¦‚ä½•åˆ¤æ–­ä¸¤ä¸ªæ— ç¯é“¾è¡¨æ˜¯å¦ç›¸äº¤, ç›¸äº¤åˆ™è¿”å›ç¬¬ä¸€ä¸ªç›¸äº¤èŠ‚ç‚¹, ä¸ç›¸äº¤åˆ™è¿”å›null.
  - å¦‚ä½•åˆ¤æ–­ä¸¤ä¸ªæœ‰ç¯é“¾è¡¨æ˜¯å¦ç›¸äº¤, ç›¸äº¤åˆ™è¿”å›ç¬¬ä¸€ä¸ªç›¸äº¤èŠ‚ç‚¹, ä¸ç›¸äº¤åˆ™è¿”å›null.

+ ç®€å•æ–¹æ³•ï¼šä½¿ç”¨å“ˆå¸Œè¡¨çš„æ–¹æ³•åˆ¤æ–­æ˜¯å¦æœ‰ç¯ï¼Œç¬¬ä¸€ä¸ªå°±æ˜¯å…¥ç¯ç»“ç‚¹
  + æœ‰ç¯çš„é“¾è¡¨ä¸€å®šèµ°ä¸å‡ºæ¥ï¼Œå¦‚æœèƒ½èµ°å‡ºæ¥ï¼Œå°±ä¸€å®šæ²¡æœ‰ç¯
+ è¿›é˜¶æ–¹æ³•ï¼šä½¿ç”¨å¿«æ…¢æŒ‡é’ˆ

#### åˆ¤æ–­æ˜¯å¦æœ‰ç¯

![image-20220724162746702](assets/image-20220724162746702.png)

- é‡‡å–å¿«æ…¢æŒ‡é’ˆæ³•. è®¾ç½®å¿«æŒ‡é’ˆfastå’Œæ…¢æŒ‡é’ˆslow.
- ç¬¬ä¸€æ¬¡å¾ªç¯, fastèµ°ä¸¤æ­¥, slowèµ°ä¸€æ­¥. å¦‚æœfast = null, åˆ™æ— ç¯è¿”å›null. å¦åˆ™fast = slow.
- å½“fast = slowæ—¶å€™, è®©fastå›åˆ°å¤´èŠ‚ç‚¹, ç„¶åfastå’Œslowæ¯æ¬¡èµ°ä¸€æ­¥. å½“fast == slowæ—¶å€™, ç›¸é‡çš„èŠ‚ç‚¹å°±æ˜¯ç¬¬ä¸€æ¬¡å…¥ç¯çš„èŠ‚ç‚¹.



#### ç®€å•è§£é¢˜å“ˆå¸Œè¡¨

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> visited = new HashSet<ListNode>();
        for(ListNode temp = headA; temp != null; temp = temp.next){
            visited.add(temp);
        }
        for(ListNode temp = headB; temp != null; temp = temp.next){
            if(visited.contains(temp)){
                return temp;
            }
        }
        return null;
    }
}
```



#### åŒæŒ‡é’ˆè§£é¢˜

+ ç¬¬ä¸€ç§æƒ…å†µæ˜¯ä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰ç›¸äº¤çš„ç»“ç‚¹
  + æ‰¾åˆ°æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œä»¥åŠæ±‚å‡ºå½“å‰çš„é“¾è¡¨æœ€åä¸€ä¸ªç»“ç‚¹é•¿åº¦
  + é“¾è¡¨äºŒçš„æœ€åä¸€ä¸ªç»“ç‚¹å’Œé•¿åº¦
+ ç¬¬äºŒç§æƒ…å†µæ˜¯ä¸¤ä¸ªé“¾è¡¨ä¹‹é—´æœ‰ç›¸åŒé‡åˆçš„ç»“ç‚¹
  + æœ€åä¸€ä¸ªç»“ç‚¹ç›¸åŒ
  + å…ˆæ±‚é•¿åº¦å’Œæœ€åä¸€ä¸ªendç»“ç‚¹

+ endç›¸åŒè¯´æ˜æ˜¯æƒ…å†µäºŒ
+ endä¸åŒè¯´æ˜æ˜¯æƒ…å†µä¸€



**golang**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    //è¿›é˜¶æ–¹æ³•  -- å’Œä¸€ä¸ªé“¾è¡¨ä¸ä¸€æ ·çš„æ˜¯ï¼šç¬¬ä¸€ä¸ªç»“ç‚¹æœ‰å¯èƒ½æ˜¯ä¸€æ ·çš„
    if headA == nil || headB == nil {
        return nil
    }
    var n int = 0;    
    pa, pb := headA, headB    //pb.Next.Next
    for pa.Next != nil {   //å‘ç°ç©ºç»“ç‚¹å°±åœä¸‹
        n++ 
        pa = pa.Next
    }
    for pb.Next != nil {
        n--    //ç»Ÿè®¡pbå’Œpaé•¿åº¦åšå·®
        pb = pb.Next
    }
    if pa != pb {
        //æœ€åçš„ç»“ç‚¹1ä¸ç›¸ç­‰
        return nil
    }
    //æ‰¾åˆ°é•¿çš„é“¾
    if n > 0 {  //paé•¿
        pa = headA
        pb = headB
    }else{
        pa = headB
        pb = headA
    }
    if n < 0 {
        //å–ç»å¯¹å€¼
        n = (-n)
    }
    //pb = headB
    for n != 0 {
        n--
        pa = pa.Next
        //å¾€å›èµ°ï¼Œç›´åˆ°æ‰¾åˆ°paç›¸åŒçš„ç»“ç‚¹
    }
    for pb != pa {    //å†æ¬¡ç›¸é‡è¯´æ˜æ‰¾åˆ°äº†ç¬¬ä¸€ä¸ªç»“ç‚¹
        pa = pa.Next
        pb = pb.Next
    }
    return pa
}
```





#### ä¸€ä¸ªé“¾è¡¨çš„è¯ï¼Œæ€ä¹ˆæ‰¾åˆ°ç¬¬ä¸€ä¸ªé‡åˆç»“ç‚¹

```go
func getIntersectionNode(head *ListNode) *ListNode {
    //è¿›é˜¶æ–¹æ³•
    if head == nil || head.Next == nil || head.Next.Next == nil {
        return nil
    }
    pa, pb := head.Next, head.Next.Next   //pb.Next.Next
    for pa != pb {
        if pa.Next == nil || pb.Next.Next == nil {
            return nil
        }
        //ä¸ç›¸ç­‰ï¼Œå°±ä¸€ç›´å¾€ä¸‹èµ°
        pa, pb = pa.Next, pb.Next.Next
    }
    
    // æ‰¾åˆ°äº†ç›¸ç­‰çš„ç»“ç‚¹
    pb = head   //ç›¸é‡äº†å¿«ç»“ç‚¹è·³åˆ°å¼€å¤´
    for pb != pa {
        pa, pb = pa.Next, pb.Next
    }
    return pa
}
```
---
markmap:
  initialExpandLevel: 1
---

## END é“¾æ¥

+ [å›åˆ°ç›®å½•](../README.md)
+ [ä¸Šä¸€èŠ‚](9.md)
+ [ä¸‹ä¸€èŠ‚](11.md)

---

+ [å‚ä¸è´¡çŒ®â¤ï¸ğŸ’•ğŸ’•](https://github.com/3293172751/Block_Chain/blob/master/Git/git-contributor.md)